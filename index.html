<!DOCTYPE html>
<html lang="en">
<!doctype html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>External Work – EUW2 (London)</title>
  <!-- Genesys Cloud JS SDK (global `platformClient`) -->
  <script src="https://sdk-cdn.mypurecloud.com/javascript/latest/purecloud-platform-client-v2.min.js" defer></script>

  <style>
    :root{
      --bg:#0b1020;
      --card:#121935;
      --ink:#e9ecf5;
      --muted:#a8b0c6;
      --brand:#7aa2ff;
      --brand-2:#a07aff;
      --ok:#47d16f;
      --warn:#ffcc66;
      --err:#ff6b6b;
      --ring: 0 0 0 3px rgba(122,162,255,.25);
      --radius: 16px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; padding:24px;
      background: radial-gradient(1200px 600px at 100% -100%, rgba(122,162,255,.08), transparent),
                  radial-gradient(1000px 500px at -40% 120%, rgba(160,122,255,.08), transparent),
                  var(--bg);
      color:var(--ink);
      font:16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
    }
    .wrap{
      max-width:780px; margin:0 auto;
    }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.08);
      border-radius:var(--radius);
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      padding:20px;
      backdrop-filter: blur(8px);
    }
    h1{
      font-size:26px; margin:0 0 4px;
      letter-spacing:.2px;
    }
    .sub{
      color:var(--muted); margin:0 0 18px; font-size:14px;
    }
    .grid{
      display:grid; gap:14px;
      grid-template-columns: 1fr 1fr;
    }
    .field{
      display:flex; flex-direction:column; gap:6px;
    }
    label{font-weight:600; color:#cbd2ea; font-size:13px;}
    select, input[type="text"]{
      appearance:none;
      padding:12px 14px;
      border-radius:12px;
      background:#0e1530;
      border:1px solid rgba(255,255,255,.12);
      color:var(--ink);
      outline:none;
      transition:.15s ease;
    }
    select:focus, input[type="text"]:focus{ box-shadow:var(--ring); border-color:rgba(122,162,255,.6); }
    input[disabled]{ color:#c6cbe0; opacity:.9 }
    .row{ display:flex; gap:12px; align-items:center; justify-content:flex-end; margin-top:10px; }
    button{
      border:0; cursor:pointer;
      padding:12px 16px; border-radius:12px;
      color:white; font-weight:700;
      background: linear-gradient(135deg, var(--brand), var(--brand-2));
      box-shadow: 0 10px 20px rgba(122,162,255,.25);
      transition: transform .05s ease, filter .15s ease, opacity .15s ease;
    }
    button:active{ transform: translateY(1px) }
    button[disabled]{ opacity:.6; cursor:not-allowed; }
    .btn-ghost{
      background:transparent; color:var(--muted); font-weight:600;
      border:1px solid rgba(255,255,255,.12);
    }
    .status{
      display:flex; align-items:center; gap:10px;
      font-size:14px; color:var(--muted); min-height:24px;
      margin-top:6px;
    }
    .dot{ width:10px; height:10px; border-radius:50%; background:var(--warn); box-shadow:0 0 12px var(--warn); }
    .ok{ background:var(--ok); box-shadow:0 0 12px var(--ok); }
    .err{ background:var(--err); box-shadow:0 0 12px var(--err); }

    /* toast */
    .toast{
      position:fixed; right:20px; bottom:20px; z-index:9999;
      background:#0f1733; color:var(--ink);
      border:1px solid rgba(255,255,255,.12);
      padding:12px 14px; border-radius:12px; min-width:220px;
      box-shadow:0 10px 30px rgba(0,0,0,.35);
      display:none;
    }
    .toast.show{ display:block; animation: pop .2s ease-out }
    @keyframes pop{ from{ transform:translateY(6px); opacity:0 } to{ transform:translateY(0); opacity:1 } }

    /* loader */
    .spinner{
      width:18px; height:18px; border-radius:50%;
      border:3px solid rgba(255,255,255,.12);
      border-top-color: var(--brand);
      animation:spin 1s linear infinite;
      margin-left:6px;
    }
    @keyframes spin{ to{ transform: rotate(360deg) } }

    @media (max-width:720px){
      .grid{ grid-template-columns: 1fr; }
      .row{ justify-content:stretch }
      .row button{ flex:1 }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Create External Work</h1>
      <p class="sub">London (EUW2) • Whitelisted agents only • “Fire-and-forget” create</p>

      <div class="grid">
        <div class="field">
          <label for="agentSelect">Agent</label>
          <select id="agentSelect" disabled>
            <option>Loading agents…</option>
          </select>
          <div class="status" id="agentStatus"><span class="dot"></span><span>Fetching allow-listed agent names…</span></div>
        </div>

        <div class="field">
          <label for="queueName">Queue</label>
          <input id="queueName" type="text" value="Loading…" disabled />
          <div class="status" id="queueStatus"><span class="dot"></span><span>Fetching queue name…</span></div>
        </div>
      </div>

      <div class="row">
        <button class="btn-ghost" id="reloginBtn" title="Re-authenticate">Re-login</button>
        <button id="createBtn" disabled>Create</button>
      </div>
      <div class="status" id="createStatus"></div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    // ======= CONFIG =======
    const OAUTH_CLIENT_ID = "YOUR_OAUTH_CLIENT_ID";
    const REDIRECT_URI = "YOUR_REDIRECT_URI"; // e.g. https://yourapp.example.com/callback
    const GC_ENV = "euw2.pure.cloud";         // London (EUW2)

    // Whitelisted agents
    const ALLOWED_USER_IDS = [
      'fa677b42-4aff-45af-b7e7-749418788b88',
      '206a7f52-4f89-446f-afbf-ac879147a7ad',
      '14ecd5fc-30f9-4214-809f-93771752bfb6',
      '79148e85-0da8-4f3e-9cdf-1ce4d832f5a4',
      '4ec6fd9a-e335-4d96-9504-05a1fbaa46a9',
      '207b29f5-8895-429c-b3bb-4879b41d8718',
      '4cd8cbf4-a8a1-4b49-9769-825d1cfc9e08',
      '6e917925-2cff-49b5-a730-55db79445280',
      'fed76596-cfa5-4fda-bb15-49985065480e',
      '660c4154-ba9b-4e84-90ec-c9c9b409ac41'
    ];

    // Single required queue
    const REQUIRED_QUEUE_ID = '4a6f26c7-2b69-4c34-99e2-e156230ec2bd';

    // ======= UTILS =======
    const $ = sel => document.querySelector(sel);
    function setStatus(el, ok, msg, isErr=false){
      const dot = el.querySelector('.dot');
      dot.classList.remove('ok','err');
      if (ok) dot.classList.add('ok');
      if (isErr) dot.classList.add('err');
      el.querySelector('span:nth-child(2)').textContent = msg;
    }
    function toast(msg){
      const t = $('#toast');
      t.textContent = msg;
      t.classList.add('show');
      setTimeout(()=> t.classList.remove('show'), 3000);
    }

    // ======= APP =======
    let client, usersApi, routingApi, conversationsApi;

    async function login(){
      client = platformClient.ApiClient.instance;
      client.setEnvironment(GC_ENV);

      // Choose one flow your app uses (implicit grant here).
      try{
        await client.loginImplicitGrant(OAUTH_CLIENT_ID, REDIRECT_URI, { state: 'euw2_ext_work' });
      }catch(e){
        console.error('Login failed:', e);
        throw e;
      }
      usersApi = new platformClient.UsersApi();
      routingApi = new platformClient.RoutingApi();
      conversationsApi = new platformClient.ConversationsApi();
    }

    async function loadAgents(){
      const agentSelect = $('#agentSelect');
      const agentStatus = $('#agentStatus');
      setStatus(agentStatus, false, 'Fetching allow-listed agent names…');

      const results = await Promise.allSettled(ALLOWED_USER_IDS.map(id => usersApi.getUser(id)));
      const users = results
        .filter(r => r.status === 'fulfilled' && r.value && !r.value.deleted)
        .map(r => r.value);

      if (!users.length){
        setStatus(agentStatus, false, 'No valid users found in allow-list.', true);
        agentSelect.innerHTML = '<option disabled>No agents</option>';
        return;
      }

      users.sort((a,b)=> (a.name||'').localeCompare(b.name||''));

      agentSelect.innerHTML = '';
      for (const u of users){
        const opt = document.createElement('option');
        opt.value = u.id;
        opt.textContent = u.name || u.id;
        agentSelect.appendChild(opt);
      }
      agentSelect.disabled = false;
      setStatus(agentStatus, true, `Loaded ${users.length} agent${users.length>1?'s':''}.`);
    }

    async function loadQueue(){
      const queueStatus = $('#queueStatus');
      const input = $('#queueName');
      setStatus(queueStatus, false, 'Fetching queue name…');
      try{
        const q = await routingApi.getRoutingQueue(REQUIRED_QUEUE_ID);
        input.value = q?.name || REQUIRED_QUEUE_ID;
        setStatus(queueStatus, true, 'Queue loaded.');
      }catch(e){
        console.error(e);
        input.value = REQUIRED_QUEUE_ID + ' (not found)';
        setStatus(queueStatus, false, 'Queue not found (ID still usable).', true);
      }
    }

    // --- YOUR creation flow (plug in your working calls here) ---
    async function createExternalWorkForAgent(agentUserId){
      // This function intentionally “fire-and-forgets” from the UI’s perspective.
      // The exact API sequence depends on your current working approach.
      //
      // ⬇️ Replace these placeholders with your known-good calls:
      //
      // 1) Create a dummy email routed to REQUIRED_QUEUE_ID
      // const convo = await conversationsApi.postConversationsEmails({ ...payloadThatRoutesToQueue... });
      //
      // 2) Force-assign the interaction participant to `agentUserId`
      // await conversationsApi.patchConversationParticipant(convo.id, theEmailParticipantId, { userId: agentUserId });
      //
      // 3) Immediately disconnect/complete it
      // await conversationsApi.postConversationDisconnect(convo.id);
      //
      // Notes:
      // - If you prefer true “silent connect”, consider enabling Auto-Answer for the queue/agents.
      // - If you ultimately just need to log non-ACD work, Work Items/Third-Party Object Routing can be cleaner.

      // For now, we just resolve immediately so the UI feels instant.
      return true;
    }

    async function init(){
      // Wire buttons
      $('#reloginBtn').addEventListener('click', async ()=>{
        $('#createBtn').disabled = true;
        $('#agentSelect').disabled = true;
        try{
          await login();
          await Promise.all([loadAgents(), loadQueue()]);
          $('#createBtn').disabled = false;
          toast('Re-authenticated.');
        }catch(e){
          toast('Login failed. Check console.');
        }
      });

      $('#createBtn').addEventListener('click', ()=>{
        const createBtn = $('#createBtn');
        const status = $('#createStatus');
        const agentId = $('#agentSelect').value;

        if (!agentId){
          toast('Pick an agent first, champ.');
          return;
        }
        createBtn.disabled = true;
        status.innerHTML = `<span class="spinner"></span><span>Creating external work…</span>`;

        // Fire-and-forget UX: do not await in the click handler; show immediate success.
        (async ()=>{
          try{
            await createExternalWorkForAgent(agentId);
            status.innerHTML = `<span class="dot ok"></span><span>Created and auto-closed.</span>`;
            toast('Created. It will auto-close in the background.');
          }catch(e){
            console.error('Create failed', e);
            status.innerHTML = `<span class="dot err"></span><span>Failed to create – check console.</span>`;
            toast('Could not create external work.');
          }finally{
            createBtn.disabled = false;
          }
        })();
      });

      // First-time bootstrap
      try{
        await login();
      }catch(e){
        toast('Login needed. Click “Re-login”.');
        return;
      }
      await Promise.all([loadAgents(), loadQueue()]);
      $('#createBtn').disabled = false;
    }

    // Kick off once SDK is loaded
    window.addEventListener('load', init);
  </script>
</body>
</html>


    <div class="row">
      <div>
        <label for="regionSelect">Genesys Cloud Region</label>
        <select id="regionSelect">
          <option value="mypurecloud.ie" selected>Dublin (mypurecloud.ie)</option>
          <option value="euw2.pure.cloud">London (euw2.pure.cloud)</option>
          <option value="mypurecloud.de">Frankfurt (mypurecloud.de)</option>
          <option value="mypurecloud.com">US-East (mypurecloud.com)</option>
          <option value="usw2.pure.cloud">US-West2 (usw2.pure.cloud)</option>
          <option value="apne2.pure.cloud">Tokyo (apne2.pure.cloud)</option>
          <option value="aps1.pure.cloud">Sydney (aps1.pure.cloud)</option>
        </select>
        <small class="hint">Pick the org’s region (Dublin vs London matters).</small>
      </div>
      <div>
        <label for="externalReference">External Reference</label>
        <input type="text" id="externalReference" placeholder="Optional ref/link">
      </div>
    </div>

    <label for="queueSelect">Select Queue</label>
    <select id="queueSelect"></select>

    <label for="userSelect">Select User</label>
    <select id="userSelect"></select>

    <div class="loader" id="loader"><div class="spinner"></div><span>Creating interaction...</span></div>
    <button id="createInteractionBtn" disabled>Create Proxy Interaction</button>
    <div id="statusMessage"></div>
  </div>

  <script>
    // =========================
    // Config you may edit
    // =========================
    const clientId = 'f2a0fa16-33cb-480b-a4ef-4766812dfb81';

    // Whitelists (unchanged)
    const whitelistedUserIds = [
      'fa677b42-4aff-45af-b7e7-749418788b88',
      '206a7f52-4f89-446f-afbf-ac879147a7ad',
      '14ecd5fc-30f9-4214-809f-93771752bfb6',
      '79148e85-0da8-4f3e-9cdf-1ce4d832f5a4',
      '4ec6fd9a-e335-4d96-9504-05a1fbaa46a9',
      '207b29f5-8895-429c-b3bb-4879b41d8718',
      '4cd8cbf4-a8a1-4b49-9769-825d1cfc9e08',
      '6e917925-2cff-49b5-a730-55db79445280',
      'fed76596-cfa5-4fda-bb15-49985065480e',
      '660c4154-ba9b-4e84-90ec-c9c9b409ac41'
    ];
    const whitelistedQueueIds = [
      '4a6f26c7-2b69-4c34-99e2-e156230ec2bd'
    ];

    // =========================
    // Region plumbing
    // =========================
    function buildEnv(host) {
      const loginBase = `https://login.${host}`;
      const apiBase   = `https://api.${host}`;
      return { loginBase, apiBase };
    }
    function getExactRedirectUri(){ return `${location.origin}${location.pathname}`; }
    function getAccessTokenFromHash() {
      const hash = window.location.hash.replace(/^#/, '');
      const params = new URLSearchParams(hash);
      return params.get('access_token');
    }
    function buildAuthorizeUrl(loginBase) {
      const redirectUri = getExactRedirectUri();
      return `${loginBase}/oauth/authorize?client_id=${encodeURIComponent(clientId)}&response_type=token&redirect_uri=${encodeURIComponent(redirectUri)}`;
    }

    // =========================
    // State
    // =========================
    let accessToken = null;
    let apiBase = 'https://api.mypurecloud.ie';
    let loginBase = 'https://login.mypurecloud.ie';

    // =========================
    // Boot
    // =========================
    document.addEventListener('DOMContentLoaded', async () => {
      const region = document.getElementById('regionSelect').value;
      ({ loginBase, apiBase } = buildEnv(region));

      accessToken = getAccessTokenFromHash();
      if (!accessToken) {
        window.location.href = buildAuthorizeUrl(loginBase);
        return;
      }

      await populateDropdowns();
      document.getElementById('createInteractionBtn').addEventListener('click', createInteraction);
      document.getElementById('queueSelect').addEventListener('change', toggleCreateButton);
      document.getElementById('userSelect').addEventListener('change', toggleCreateButton);
      document.getElementById('regionSelect').addEventListener('change', () => {
        const newRegion = document.getElementById('regionSelect').value;
        ({ loginBase, apiBase } = buildEnv(newRegion));
        window.location.hash = '';
        window.location.href = buildAuthorizeUrl(loginBase);
      });
      toggleCreateButton();
    });

    // =========================
    // UI helpers
    // =========================
    function toggleCreateButton() {
      const btn = document.getElementById('createInteractionBtn');
      btn.disabled = !(document.getElementById('queueSelect').value && document.getElementById('userSelect').value);
    }
    function showLoader(show){ document.getElementById('loader').style.display = show ? 'block' : 'none'; }
    function showStatusMessage(msg, type='success'){ const el = document.getElementById('statusMessage'); el.style.display='block'; el.className = type; el.innerHTML = msg; }

    // =========================
    // Data loading
    // =========================
    async function fetchAllPages(url) {
      let all = [], pageNumber = 1, more = true;
      while (more) {
        const r = await fetch(`${url}?pageNumber=${pageNumber}&pageSize=25`, { headers:{ Authorization:`Bearer ${accessToken}` }});
        if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
        const data = await r.json();
        all = all.concat(data.entities || []);
        more = data.pageCount > pageNumber; pageNumber++;
      }
      return all;
    }

    async function populateDropdowns() {
      try {
        const queues = await fetchAllPages(`${apiBase}/api/v2/routing/queues`);
        const users  = await fetchAllPages(`${apiBase}/api/v2/users`);

        const queueSelect = document.getElementById('queueSelect');
        const filteredQueues = queues.filter(q => whitelistedQueueIds.includes(q.id));
        filteredQueues.forEach(q => queueSelect.add(new Option(q.name, q.id)));

        const userSelect = document.getElementById('userSelect');
        const filteredUsers = users.filter(u => whitelistedUserIds.includes(u.id));
        filteredUsers.forEach(u => userSelect.add(new Option(u.name, u.id)));

        if (!filteredQueues.length) { queueSelect.add(new Option('No allowed queues','')); queueSelect.disabled = true; }
        if (!filteredUsers.length) { userSelect.add(new Option('No allowed users','')); userSelect.disabled = true; }
      } catch (e) {
        console.error(e);
        showStatusMessage(`Error loading data: ${e.message}`, 'error');
      }
    }

    // =========================
    // Guards (config/eligibility)
    // =========================
    async function ensureQueueAllowsManualAssignment(queueId) {
      const r = await fetch(`${apiBase}/api/v2/routing/queues/${queueId}`, {
        headers:{ Authorization:`Bearer ${accessToken}` }
      });
      if (!r.ok) throw new Error(`Can't read queue: ${r.status} ${r.statusText}`);
      const q = await r.json();
      const enabled = !!(q.enableManualAssignment ?? q.manualAssignmentEnabled);
      if (!enabled) throw new Error('Manual assignment is disabled on this queue (Admin → Queues → General → “Enable Manual Assignment”).');
    }
    async function ensureUserIsQueueMember(queueId, userId) {
      let page=1, found=false;
      while(!found) {
        const r = await fetch(
          `${apiBase}/api/v2/routing/queues/${queueId}/members?pageNumber=${page}&pageSize=100`,
          { headers:{ Authorization:`Bearer ${accessToken}` } }
        );
        if (!r.ok) throw new Error(`Can't list queue members: ${r.status} ${r.statusText}`);
        const data = await r.json();
        found = (data.entities||[]).some(m => m.id === userId);
        if (found) break;
        if (!data.nextUri) break;
        page++;
      }
      if (!found) throw new Error('Selected user is not a member of the selected queue.');
    }

    // =========================
    // Race guards (state/participants)
    // =========================
    async function waitForAcdParticipant(conversationId, queueId, { timeoutMs=20000, intervalMs=500 } = {}) {
      const start = Date.now();
      while (Date.now() - start < timeoutMs) {
        const r = await fetch(`${apiBase}/api/v2/conversations/${conversationId}`, {
          headers:{ Authorization:`Bearer ${accessToken}` }
        });
        if (r.ok) {
          const c = await r.json();
          const acd = (c.participants||[]).find(p => p.purpose === 'acd' && p.queueId === queueId);
          if (acd) return acd;
        }
        await delay(intervalMs);
      }
      throw new Error('Timed out waiting for ACD participant on the queue.');
    }

    async function waitForAgentLeg(conversationId, userId, { timeoutMs=20000, intervalMs=500 } = {}) {
      const start = Date.now();
      while (Date.now() - start < timeoutMs) {
        const r = await fetch(`${apiBase}/api/v2/conversations/${conversationId}`, {
          headers:{ Authorization:`Bearer ${accessToken}` }
        });
        if (r.ok) {
          const c = await r.json();
          const agent = (c.participants||[]).find(p =>
            (p.purpose === 'agent' || p.purpose === 'user') &&
            p.userId === userId
          );
          if (agent) return agent;
        }
        await delay(intervalMs);
      }
      throw new Error('Agent leg for selected user did not appear in time.');
    }

    function delay(ms){ return new Promise(r => setTimeout(r, ms)); }

    // =========================
    // Main flow (PATCH-based assignment)
    // =========================
    async function createInteraction() {
      const queueId = document.getElementById('queueSelect').value;
      const userId  = document.getElementById('userSelect').value;
      const externalReference = (document.getElementById('externalReference').value || '').trim();

      if (!queueId || !userId) return showStatusMessage('Please select both a queue and a user', 'error');

      showLoader(true); showStatusMessage('', 'success');

      try {
        await ensureQueueAllowsManualAssignment(queueId);
        await ensureUserIsQueueMember(queueId, userId);

        // 1) Create the email conversation on the selected queue
        const createRes = await fetch(`${apiBase}/api/v2/conversations/emails`, {
          method:'POST',
          headers:{ Authorization:`Bearer ${accessToken}`, 'Content-Type':'application/json' },
          body: JSON.stringify({
            queueId,
            provider:'QualityForm',
            direction:'INBOUND',
            fromName:'External Work',
            attributes: { 'External Link': externalReference }
          })
        });
        if (!createRes.ok) throw new Error(await formatHttpError('Error creating interaction', createRes));
        const interaction = await createRes.json();
        const conversationId = interaction.id;

        // 2) Wait for the ACD leg on that queue
        const acd = await waitForAcdParticipant(conversationId, queueId);

        // 3) PATCH the email conversation to set the ACD participant's userId to the selected user
        //    (This mirrors the schema you posted; include only the fields we intend to change.)
        const patchBody = {
          participants: [
            {
              id: acd.id,
              userId: userId,
              // Optional: you can set a friendly name on the participant if you wish
              // name: document.getElementById('userSelect').selectedOptions[0]?.text || undefined
            }
          ],
          // Optional: carry an external tag for later reporting
          externalTag: externalReference || undefined
        };

        const patchAssign = await fetch(`${apiBase}/api/v2/conversations/emails/${conversationId}`, {
          method:'PATCH',
          headers:{ Authorization:`Bearer ${accessToken}`, 'Content-Type':'application/json' },
          body: JSON.stringify(patchBody)
        });
        if (!patchAssign.ok) throw new Error(await formatHttpError('Participant patch failed', patchAssign));

        // 4) Verify an agent/user leg for that user now exists
        await waitForAgentLeg(conversationId, userId);

        // 5) Disconnect via the same PATCH endpoint (your requested behaviour)
        const patchDisconnect = await fetch(`${apiBase}/api/v2/conversations/emails/${conversationId}`, {
          method:'PATCH',
          headers:{ Authorization:`Bearer ${accessToken}`, 'Content-Type':'application/json' },
          body: JSON.stringify({ state: 'disconnected' })
        });
        if (!patchDisconnect.ok) throw new Error(await formatHttpError('Disconnect failed', patchDisconnect));

        const queueName = document.getElementById('queueSelect').selectedOptions[0]?.text || 'Queue';
        const userName  = document.getElementById('userSelect').selectedOptions[0]?.text || 'User';
        showStatusMessage(`Interaction for <b>${userName}</b> in <b>${queueName}</b> created and assigned (via PATCH), then disconnected for filing. Check <b>Performance &gt; Workspace &gt; Interactions</b>.`);
      } catch (e) {
        console.error(e);
        showStatusMessage(e.message, 'error');
      } finally {
        showLoader(false);
      }
    }

    // =========================
    // Error helper
    // =========================
    async function formatHttpError(prefix, res) {
      let txt = '';
      try { txt = await res.text(); } catch (_) {}
      return `${prefix}: ${res.status} ${res.statusText}${txt ? ' — ' + txt : ''}`;
    }
  </script>
</body>
</html>
