<script>
  // --- Helper: poll the conversation until the selected user is on it ---
  async function waitForAssignment(conversationId, userId, { timeoutMs = 12000, intervalMs = 600 } = {}) {
    const deadline = Date.now() + timeoutMs;
    while (Date.now() < deadline) {
      const details = await apiFetch(`${API_BASE}/api/v2/conversations/${conversationId}`);
      const assigned = (details.participants || []).some(p => {
        // user may be present as p.user.id or p.userId depending on payload shape
        const pid = (p.user && p.user.id) || p.userId;
        return pid === userId;
      });
      if (assigned) return true;
      await new Promise(r => setTimeout(r, intervalMs));
    }
    return false;
  }

  // --- Replacement: createInteraction() ---
  async function createInteraction() {
    const queueId = document.getElementById('queueSelect').value;
    const userId  = document.getElementById('userSelect').value;
    const externalReference = (document.getElementById('externalReference').value || '').trim();

    if (!queueId || !userId) return showStatusMessage('Please select both a queue and a user', 'error');

    clearStatus();
    showLoader(true);
    setButtonDisabled(true);

    try {
      // 1) Create “dummy” email that lands in the queue
      const interaction = await apiFetch(`${API_BASE}/api/v2/conversations/emails`, {
        method: 'POST',
        body: JSON.stringify({
          queueId,
          provider: 'QualityForm',
          direction: 'INBOUND',
          fromName: 'External Work',
          attributes: externalReference ? { 'External Link': externalReference } : {}
        })
      });
      const conversationId = interaction.id;

      // 2) Assign it to the selected agent (try /assign first)
      let assignmentSucceeded = false;
      try {
        await apiFetch(`${API_BASE}/api/v2/conversations/${conversationId}/assign`, {
          method: 'POST',
          body: JSON.stringify({ userId })
        });
        assignmentSucceeded = true;
      } catch (assignErr) {
        // Fallback: PATCH a suitable participant with userId
        console.warn('Assign endpoint failed; falling back to participant PATCH', assignErr);
        const details = await apiFetch(`${API_BASE}/api/v2/conversations/${conversationId}`);
        // Prefer an ACD/agent/user purpose participant (email leg may be "agent" or "acd")
        const p = (details.participants || []).find(x => {
          const purp = (x.purpose || '').toLowerCase();
          return purp === 'agent' || purp === 'user' || purp === 'acd';
        });
        if (p) {
          await apiFetch(`${API_BASE}/api/v2/conversations/${conversationId}/participants/${p.id}`, {
            method: 'PATCH',
            body: JSON.stringify({ userId })
          });
          assignmentSucceeded = true;
        } else {
          console.warn('No suitable participant to patch; assignment not confirmed yet.');
        }
      }

      // 3) VERIFY the assignment before closing (poll briefly)
      // We only proceed to disconnect if we actually see the selected user on the conversation
      const isAssigned = assignmentSucceeded &&
        (await waitForAssignment(conversationId, userId, { timeoutMs: 12000, intervalMs: 600 }));

      if (!isAssigned) {
        throw new Error('Could not confirm assignment to the selected user. Aborting disconnect.');
      }

      // 4) (Optional) link an external contact if you provided a reference
      try {
        if (externalReference) {
          const contact = await apiFetch(`${API_BASE}/api/v2/externalcontacts/contacts`, {
            method:'POST',
            body: JSON.stringify({
              firstName: 'External',
              lastName: externalReference || 'Work Item',
              notes: [`Ref: ${externalReference}`],
              addresses:[], phoneNumbers:[], emailAddresses:[]
            })
          });
          await apiFetch(`${API_BASE}/api/v2/externalcontacts/conversations/${conversationId}`, {
            method:'PUT',
            body: JSON.stringify({ externalContactId: contact.id })
          });
        }
      } catch (e) {
        console.warn('External contact link failed (non-blocking)', e);
      }

      // 5) Disconnect/complete the email ONLY AFTER assignment is confirmed
      await apiFetch(`${API_BASE}/api/v2/conversations/emails/${conversationId}`, {
        method:'PATCH',
        body: JSON.stringify({ state: 'disconnected' })
      });

      const queueName = getSelectedText('queueSelect');
      const userName  = getSelectedText('userSelect');
      showStatusMessage(
        `Interaction for <b>${escapeHTML(userName)}</b> in <b>${escapeHTML(queueName)}</b> created, assigned, and stored (Performance → Workspace → Interactions).`,
        'success'
      );
    } catch (e) {
      console.error(e);
      showStatusMessage(`Error creating/assigning interaction: ${escapeHTML(e.message)}`, 'error');
    } finally {
      showLoader(false);
      setButtonDisabled(false);
    }
  }
</script>
